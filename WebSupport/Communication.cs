using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
namespace WebSupport
{
    public static class Communication
    {
        public enum Command : int
        {
            // NOTE: If you change this enumerator, you must also change the enumerator in WebSupport Communication.vs
            GetContacts = 0,
            SetNewContact = 1,
            GetMessages = 2,
            SetNewPost = 3,
            /// <summary>
            /// Public encryption key. Note: This command is only for debug mode, in production the public key must be passed to the device by scanning the QR code generated by the browser!
            /// </summary>
            SetEncryptionKey = 4,
            /// <summary>
            /// Used to pair the device via the public key hash
            /// </summary>
            Pair = 5,
            /// <summary>
            /// Command that is used only by the browser application to ask the proxy if there are new commands to execute
            /// </summary>
            GetPushNotifications = 6,
            /// <summary>
            /// Command used by the browser, to request the avatar image of a contact
            /// </summary>
            GetAvatar = 7,
        }

        private static Aes MyEncryptionAes; //It is the key with which the browser will have to use to send me the commands. This key must be transmitted to the browser (encrypted) to allow it to communicate with me!
        private static readonly byte[] Exponent = Base64UrlDecode("AQAB");
        private static byte[] Base64UrlDecode(string text)
        {
            text = text.Replace('_', '/').Replace('-', '+');
            switch (text.Length % 4)
            {
                case 2:
                    text += "==";
                    break;
                case 3:
                    text += "=";
                    break;
            }
            return Convert.FromBase64String(text);
        }
        private static byte[] _BrowserPubblicKey;
        private static byte[] HashPubKey;
        /// <summary>
        /// Browser-generated public key that must be used to encrypt data
        /// </summary>
        internal static byte[] BrowserPubblicKey
        {
            get { return _BrowserPubblicKey; }
            set
            {
                _BrowserPubblicKey = value;
                using (var sha256Hash = SHA256.Create())
                {
                    HashPubKey = sha256Hash.ComputeHash(_BrowserPubblicKey);
                    MyEncryptionAes = AesCbc.GenerateKey();
                    // We do the Pair with the hash of the public key to not let the server know anything about the keys used (improve security and privacy)
                    SendCommandWithEncryptRsa256(Command.Pair, HashPubKey, HashPubKey, MyEncryptionAes.Key, MyEncryptionAes.IV);
                }
            }
        }

        /// <summary>
        /// Indicates who the command is intended for (proxy or browser), and possibly the purpose
        /// </summary>
        public enum Purpose : ushort
        {
            Forwarding,
            ForwardingEncryptRsa256,
            ToProxy,
            /// <summary>
            /// Parameter used only for communication between browser and proxy to read any push messages sent by the device
            /// </summary>
            GetPushNotifications,
            /// <summary>
            /// Used only in debug mode to send the public key from the browser to the device. normally the public key must be scanned by the QR code
            /// The public key is not encrypted because the exchange of cryptographic keys has not yet taken place.
            /// </summary>
            SetEncryptionKey,
        }

        /// <summary>
        /// Send a command to the browser via the proxy (the command has parameters)
        /// </summary>
        /// <param name="command">Command</param>
        /// <param name="values"></param>
        public static void SendCommand(Command command, Purpose purpose = Purpose.Forwarding, params byte[][] values)
        {
            // Encryption inside the library is not necessary because this data is already encrypted
            if (ProxyWebConnection.WebProxy != null)
            {
                var data = EncryptedMessaging.Functions.JoinData(false, values);
                data = BitConverter.GetBytes((int)command).Combine(data);
                var encrypred = EncryptOutcomingData(data);
                ProxyWebConnection.Context.Messaging.SendCommandToSubApplication(ProxyWebConnection.WebProxy, BitConverter.ToUInt16(Encoding.ASCII.GetBytes("web"), 0), (ushort)purpose, true, false, encrypred);
            }
        }

        /// <summary>
        /// Send a command to the browser via the proxy (the command has parameters)
        /// </summary>
        /// <param name="command">Command</param>
        /// <param name="values"></param>
        public static void SendCommandWithEncryptRsa256(Command command, byte[] dataForProxy, params byte[][] values)
        {
            // Encryption inside the library is not necessary because this data is already encrypted
            if (ProxyWebConnection.WebProxy != null)
            {
                var data = EncryptedMessaging.Functions.JoinData(false, values);
                data = BitConverter.GetBytes((int)command).Combine(data);
                var encrypred = EncryptRsa256(data, BrowserPubblicKey, Exponent);
                ProxyWebConnection.Context.Messaging.SendCommandToSubApplication(ProxyWebConnection.WebProxy, BitConverter.ToUInt16(Encoding.ASCII.GetBytes("web"), 0), (ushort)Purpose.ForwardingEncryptRsa256, true, true, dataForProxy, encrypred);
            }
        }

        /// <summary>
        /// Send a command to the browser via the proxy (the command has parameters)
        /// </summary>
        /// <param name="purpose">Command</param>
        /// <param name="values"></param>
        public static void SendCommandToProxy(Purpose purpose, params byte[][] values)
        {
            // Encryption inside the library is not necessary because this data is already encrypted
            if (ProxyWebConnection.WebProxy != null)
            {
                ProxyWebConnection.Context.Messaging.SendCommandToSubApplication(ProxyWebConnection.WebProxy, BitConverter.ToUInt16(Encoding.ASCII.GetBytes("web"), 0), (ushort)purpose, true, true, values);
            }
        }

        /// <summary>
        /// When the user performs operations in the browser, he sends commands to the device that responds with the same command name and sends the requested information by encrypting it with the public key scanned via the QR code. Any data and parameters received are encrypted with the key generated by the device (the key was previously securely sent to the browser when pairing was performed).
        /// </summary>
        /// <param name="purpose">Purpose</param>
        /// <param name="encryptedData">Data</param>
        public static void ProcessIncomingCommand(Purpose purpose, byte[] encryptedData)
        {
#if DEBUG
            if (purpose == Purpose.SetEncryptionKey)
            {
                // encryptedData is not encrypted, because it is the exchange of the public key
                SendCommand(Command.SetEncryptionKey, purpose);
                BrowserPubblicKey = encryptedData; // In debug phase to speed up development times and facilitate use with the emulator, the public key is not scanned by the QR code but sent from the browser via the proxy which must also be in debug mode.
                return;
            }
#endif
            if (MyEncryptionAes == null)
                return;
            var data = DecryptIncomingData(encryptedData);
            var command = (Command)BitConverter.ToUInt32(data, 0);
            data = data.Skip(4);
            EncryptedMessaging.Contact contact;
            string chatIdString; // Value that is treated as a string because JavaScript does not support Ulong
            string jsonData;
            switch (command)
            {
                case Command.GetContacts:
                    var contacts = new List<ContactJson>();
                    ProxyWebConnection.Context.Contacts.ForEachContact((EncryptedMessaging.Contact eachContact) => contacts.Add(new ContactJson(eachContact)));
                    jsonData = JsonConvert.SerializeObject(contacts.ToArray());
                    SendCommand(command, default, Encoding.ASCII.GetBytes(jsonData));  // Encryption inside the library is not necessary because this data is already encrypted
                    break;
                case Command.SetNewContact:
                    break;
                case Command.GetMessages:
                    var parts = Encoding.ASCII.GetString(data).Split(' ');
                    chatIdString = parts[0];
                    var creationTicksString = parts.Length > 1 ? parts[1] : null;
                    var messages = new List<MessageJson>();
                    if (ulong.TryParse(chatIdString, out var chatId))
                    {
                        contact = ProxyWebConnection.Context.Contacts.GetContact(chatId);
                        if (contact != null)
                        {
                            DateTime receprionAntecedent = default;
                            if (long.TryParse(creationTicksString, out var ticks))
                                receprionAntecedent = new DateTime(ticks);
                            void addMessage(EncryptedMessaging.Message message, bool isMy) => messages.Add(new MessageJson(message, isMy));
                            contact.GetMessages((EncryptedMessaging.Message message, bool isMy) => addMessage(message, isMy), receprionAntecedent: receprionAntecedent);
                        }
                    }
                    SendMessages(messages, command);
                    break;
                case Command.SetNewPost:
                    var jsonStringMessage = Encoding.ASCII.GetString(data);
                    var jsonMessage = JsonConvert.DeserializeObject<MessageJson>(jsonStringMessage);
                    if (Enum.TryParse(jsonMessage.Type, out EncryptedMessaging.MessageFormat.MessageType type))
                    {
                        var toContact = ProxyWebConnection.Context.Contacts.GetContact((ulong)jsonMessage.ChatId);
                        if (toContact != null)
                        {
                            var dataToSend = type == EncryptedMessaging.MessageFormat.MessageType.Text ? Encoding.Unicode.GetBytes(jsonMessage.Text) : jsonMessage.Data;
                            ProxyWebConnection.Context.Messaging.SendMessage(type, dataToSend, toContact, jsonMessage.ReplyToPostId);
                        }
                    }
                    break;
                case Command.SetEncryptionKey:
                    break;
                case Command.GetAvatar:
                    chatIdString = Encoding.ASCII.GetString(data);
                    contact = ProxyWebConnection.Context.Contacts.GetContact(ulong.Parse(chatIdString));
                    SendCommand(command, default, Encoding.ASCII.GetBytes(chatIdString), contact.Avatar);
                    break;
                default:
                    break;
            }
        }

        internal static void SendMessages(IEnumerable<MessageJson> messagesJson, Command replyToCommand = Command.GetMessages)
        {
            var jsonData = JsonConvert.SerializeObject(messagesJson);
            SendCommand(replyToCommand, default, Encoding.ASCII.GetBytes(jsonData));
        }

        private static byte[] DecryptIncomingData(byte[] encryptedData)
        {
            return MyEncryptionAes == null || encryptedData == null || encryptedData.Length == 0
                ? (new byte[0])
                : AesCbc.Decrypt(encryptedData, MyEncryptionAes);
        }

        private static byte[] EncryptOutcomingData(byte[] encryptedData)
        {
            return MyEncryptionAes == null || encryptedData == null || encryptedData.Length == 0
                ? (new byte[0])
                : AesCbc.Encrypt(encryptedData, MyEncryptionAes);
        }

        /// <summary>
        /// Encrypt the data with the public key - RSA-OAEP-256
        /// Used internally to encrypt with the public key generated by the browser. The production key is passed to the device with a scanned QR code
        /// </summary>
        /// <param name="data">Data to be encrypted must be maximum 190 bytes</param>
        /// <param name="modulus">Modulus</param>
        /// <param name="exponent">Exponent</param>
        /// <returns>Encrypted data 256 bytes</returns>
        static private byte[] EncryptRsa256(byte[] data, byte[] modulus, byte[] exponent)
        {
#if DEBUG
            //if (data.Length > 190)
            //    System.Diagnostics.Debugger.Break(); // Data to be encrypted must be maximum 190 bytes

#endif
            var result = new byte[0];
            using (var rsa = RSA.Create())
            {
                var rsaParams = new RSAParameters
                {
                    Modulus = modulus,
                    Exponent = exponent,
                };
                rsa.ImportParameters(rsaParams);
                var chunks = Split(data); // data larger than 190 bites cannot be encrypted, so I divide the data into smaller chunks
                foreach (var chunk in chunks)
                {
                    var encryptedChunk = rsa.Encrypt(chunk, RSAEncryptionPadding.OaepSHA256);
                    result = result.Combine(encryptedChunk);
                }
            }
            return result;
        }

        static private List<byte[]> Split(byte[] data, int chunkSize = 190)
        {
            byte[] buffer;
            var result = new List<byte[]>();
            for (var i = 0; i < data.Length; i += chunkSize)
            {
                var blockSize = chunkSize;
                if (data.Length - i < blockSize)
                    blockSize = data.Length - i;
                buffer = new byte[blockSize];
                Array.Copy(data, i, buffer, 0, blockSize);
                result.Add(buffer);
            }
            return result;
        }
    }
}
